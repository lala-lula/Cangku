/**最小生成树有两种算法，一种是Prim算法，另一种是Kruskal算法，这两种算法使用了最小生成树的MST性质：假设N={V,{E}}是一个联通网，
   U是顶点集V的一个非空子集。若（u，v）是一条具有最小权的边，其中u属于U，v属于V-U，则必存在一颗包含边(u,v)的最小生成树。
   Prim算法：假设N={V,{E}}是一个联通网，算法从U={u0}，TE={}（边）开始，从边（u,v)中,u属于U，v属于V-U，找出最小的边（u0,v0),将
   该边并入TE{}，同时将顶点v0并入U，直到U=V结束。
)  Kruskal算法：假设N={V,{E}}是一个联通网，，初始状态为只有n个顶点而无边的非连通图，每个顶点自成一个联通分量，选择权值最小的
   边，若该边的两个顶点在不同的联通分量中，使该边的两个顶点并入同一联通分量，否则，选择下一条代价最小的边，直到所有顶点在同一
   联通分量中结束。
   两个算法均体现了贪心算法。
**/
** c++中sort排序函数，需加头文件#include<algorithm>;和uesing namespace std;该排序函数默认从小到大排序，sort（，，），第一个参
   数是需要排序的内容的首地址，第二个参数是需要排序的内容的末尾地址的下一个地址，第三个参数是自定义的cmp排序规则函数（可选），
   cmp是bool类型的，返回值是 return （）<|>（），<是按从小到大排序，>是从大到小排序。
